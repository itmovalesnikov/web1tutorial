Это гайд по развёртыванию первой лабораторной работы по веб-программированию
на **helios** и настройке **Apache HTTPD**. Здесь не будет 
инструкций по разработке и сборке java приложения, написанию сайта и 
подключению к **helios** *(может быть, они будут потом, в отдельных страницах)*. 
Так же многие пути специфичны для нашего **helios**, поэтому для работы 
локально или в `docker` придётся действовать самостоятельно.

# Архитектура
В данной работе наше приложение разделено на 2 части

## Apache
Первая часть это Apache http сервер. 

URL, который мы вводим в браузервыглядит, как 
`<протокол>://<адрес>/<путь>`. Путь URL обычно соответствует 
реальному пути в файловой системе сервера относительно некоторой папки.

Пусть `www/` это папка где мы храним файлы сервера, сопоставим пути:

| URL клиента | Файл на сервере |
|-----|------|
| http://example.com/ | www/index.html |
| http://example.com/script.js | www/script.js |
| http://example.com/style.css | www/style.css |
| http://example.com/files/ | www/files/index.html |
| http://example.com/files/index.html | www/files/index.html |
| http://example.com/images/pic1.png | www/images/pic1.png |

Путь `http://example.com/` понимается как `http://example.com/index.html`.
Это сделано для удобства, и такое поведение определяется в настройках сервера.


Как можно заметить, разные сайты могут отличаться друг от друга 
только файлами в `www/`. Значит они могут использовать одно и то 
же приложение для раздачи файлов. Apache как раз и является одним 
из таких приложений.

Мы могли бы писать своё приложение для каждого сайта, но уже ему
придётся раздавать файлы, работать с шифрованием, сжатием,
кэшированием и делать другие одинаковые для большинства сайтов 
задачи.

Поэтому есть подход, где основным сервером является Apache или
Nginx, а логика работы конкретного сайта выносится в самописное
приложение *(что мы и будем делать)*.

В этой работе Apache отвечает за раздачу **html**, **css**, **javascript**
и перенаправление запроса на проверку попадания нашему fastcgi приложению

## FastCGI
FastCGI - это протокол для общения веб-сервера *(вроде Apache)* 
и приложений *(по типу нашего на java)*. Устройство протокола разбирать
не будем, по сути он просто передаёт http запросы и ответы в более 
эффективном виде.

*(fastcgi имеет разные способы подключения, но мы будем рассматривать
только TCP сервер)*

Fastcgi приложение так же как и Apache является TCP сервером, но c 
ним работает только основное приложение *(в нашем случае Apache)*. 
Клиентам доступ к нему должен быть запрещён.
 
Apache отправляет fastcgi приложению запросы адресованные только для него.
Это запросы по путям URL которые соответствуют не реальным файлам и папкам,
как в примере выше, а адресам fcgi серверов *(мы прописываем сопоставление их
в конфигурационном файле Apache)*.

Часто используют путь `http://example.com/fcgi-bin/` для маршрутов к 
FastCGI-приложениям. В нашем случае это будет 
`http://<адрес>/fcgi-bin/check_hit` где файла `check_hit` может и не 
существовать, но это ключ к адресу нашего fcgi приложения.

В задании этой лабораторной работы наш fastcgi должен принимать 
координаты точки и значение радиуса и возвращать факт попадания, 
время на сервере и время выполнения. Apache просто перенаправит 
запрос на `/fcgi-bin/check_hit` к нашему приложению.

# Настройка Apache HTTPD на **helios**
Само приложение сервера называется `httpd` где `http` - это название
протокола, а `d` сокращение от `daemon`, то есть демон, служба, сервис,
некая фоновая задача. Это исполняемый файл, на Unix-подобных системах
принято оставлять исполняемые файлы без расширений по типу `.exe`.

Обычно на одну операционную систему запускается один `httpd`, и уже
через конфигурацию он дробится на логические сервера. Но нам надо
запустить свой экземпляр сервера от своего пользователя 

У сервера есть своя рабочая папка которая называется `ServerRoot` 
*(root - корень, так называют папку отностельно которой ищутся
все другие директории и файлы)*, обычно это одна из системных 
папок и она меняется от системы к системе.

## Структура сервера
Мы же создадим свой **ServerRoot** такого вида

*(можно взять из этого репозитория)*
```
httpd
├── etc/
│   └── apache24/
│       └── httpd.conf
├── fcgi-bin/
├── logs/
│   ├── access.log
│   └── error.log
├── run/
│   ├── httpd.pid # будет создан при запуске
│   └── mutex-dir/
└── www/
    └── index.html
```
- `httpd/` - это и есть **ServerRoot** - папка нашего сервера, мы будем указывать
его при запуске
  - `etc/apache24/` - здесь apache будет искать файлы с его настройками. 
  Путь может показаться странным, но это стандартный путь файлов конфигурации
  в **FreeBSD** относительно **ServerRoot** *(при стандартном системном 
  ServerRoot, его также используют и другие программы, поэтому путь такой длинный.
  Изменить в конфигурации мы его не можем, т.к. сама конфигурация ищется по нему,
  можно указать его при запуске, но придётся писать лишние буквы при
  каждом запуске)*
    - `httpd.conf` - наши настройки, `.conf` сокращение от **config**,
    это текстовый файл который мы подробно рассмотрим ниже
  - `fcgi-bin/` - до **fastcgi** было принято класть **cgi** скрипты в папку
  `cgi-bin/`. У нас же она пустая т.к. fastcgi приложение запускается
  отдельно от веб сервера
  - `logs/` - папка с логами, логи - это файлы в которые сервер будет записывать
  происходящие с ним события
    - `access.log` - файл в который будут сохраняться запросы клиентов с
    дополнительной информацией
    - `error.log` - сюда будут добавляться сообщения об ошибках, если что-то
    не работает, можно заглянуть за подробной информацией
  - `run/` - папка для файлов нужных во время работы сервера, пока он *running*
    - `httpd.pid` - это текстовый файл, который при запуске будет содержать
    число - уникальный номер процесса сервера в системе, благодаря ему мы можем
    управлять уже запущенным сервером
    - `mutex-dir/` - директория в которой будут создаваться файлы необходимые
    для синхронизации работы сервера *(разбирать мы это не будем)*
  - `www/` - это папка с файлами доступными пользователю, именно сюда мы
  положим наши html, скрипты, стили, картинки.
    - `index.html` - основная html страница, которая будет отдаваться по запросу
    `http://<адрес>/`
## httpd.conf

На [se.ifmo.ru](https://se.ifmo.ru/courses/web) нам дают шаблон, но он показался
мне очень перегруженным и сложным для понимания и изменения под конкретного 
пользователя. Поэтому я написал свой конфиг с комментариями.

[Смотреть файл](./httpd/etc/apache24/httpd.conf)

Здесь не нужно менять пути. Настройка под каждого студента ограничивается
изменением переменных SERVER_PORT и FCGI_PORT определённых в начале файла
```
Define SERVER_PORT <порт для веб сервера>
Define FCGI_PORT   <порт нашего fastcgi приложения>
```
Рекомендую выбрать 2 соседних порта в диапазоне от 10000 до 60000.
Лучше выбрать случайным образом или как первые 5 цифр isu, например
```
Define SERVER_PORT 58967
Define FCGI_PORT 58968
```
Важно чтобы 2 человека не запустили одновременно сервера на одинаковых
портах, иначе будет ошибка.

Следует запомнить эти числа, **SERVER_PORT** понадобится при подключении
из браузера, а **FCGI_PORT** при запуске java приложения.

## Установка и запуск

### 1. Клонирование репозитория
Для начала нужно подключится к helios и клонировать этот репозиторий
```bash
git clone https://github.com/itmovalesnikov/web1tutorial.git
```
После нужно перейти в папку репозитория командой
```bash
cd web1tutorial/
```

### 2. Поменять порты
Открыть `httpd.conf`
```bash
vim httpd/etc/apache24/httpd.conf
```
и поменять 
```
Define SERVER_PORT 58967
Define FCGI_PORT 58968
```
на свои порты

### 3. Запуск

```bash
httpd -d $(realpath ./httpd)
```

При запуске `httpd` нужно передать ему ServerRoot, это 
делается через опцию `-d <путь>`. К сожалению, когда я 
передавал просто `httpd -d ./httpd`, наблюдались проблемы 
с двойной подстановкой пути, поэтому лучше передавать 
абсолютный путь через `realpath`. 

Конструкция 
`$(<команда>)` при выполнении заменяется на результат её 
выполнения, в нашем случае:
```bash 
[s000000@helios ~/web1tutorial]$ realpath ./httpd
/home/studs/s000000/web1tutorial/httpd
```
И значит
```bash
[s000000@helios ~/web1tutorial]$ httpd -d $(realpath ./httpd)
```
Будет пониматься как 
```bash
[s000000@helios ~/web1tutorial]$ httpd -d /home/studs/s000000/web1tutorial/httpd
```


Далее, если он не упал с очевидной ошибкой, можно проверить
работу через
```
curl http://localhost:<ваш SERVER_PORT>/
```
Если результат похож на это
```bash2
<head>
    <meta charset="UTF-8">
    <title>Apache на Helios</title>
</head>
<body>
    <h1>Привет от Apache HTTPD с Helios!</h1>
    <p>Сервер успешно запущен и работает.</p>
</body>
</html>
```
то всё работает и можно переходить далее.

Можно остановить сервер командой
```bash
pkill httpd
```
Но в репозитории лежат более аккуратные скрипты запуска,
остановки и перезапуска. Рекомендую пользоваться ими, но важно,
чтобы они были в текущей папке.
```bash
./start.sh
./stop.sh
./restart.sh
```

### 4. Проброс порта
К этому моменту сервер работает и надо подключиться к нему из
браузера. Но, если бы мы могли просто подключиться к любому
порту, то каждый бы в интернете мог сделать так же. Поэтому
порты закрыты. Есть разные решения проблемы, но я рекомендую
пробросить порт через SSH.

Проброс порта позволяет подключаться к серверу не напрямую, а
поверх ssh, через защишённый канал. Работает это так, что
один из портов вашего компьютера соединён с одним из внутренних
портов сервера, а ssh передаёт между ними данные.

Так мы соединим 8080 порт *(можно и другой)* вашего компьютера с 
`<SERVER_PORT>` портом helios, на котором и работает сайт.

Это делается через SSH с опцией `-L`, получается команда вида
```bash
# эту команду нужно запускать на вашем устройстве
ssh -N -L 8080:localhost:<ваш SERVER_PORT> <ваша обычная команда подключения к helios>
```
- `-L <локальный порт>:<удалённый сервер>:<удалённый порт>` -
говорит пробросить порт 8080 вашего компьютера на 
localhost:<ваш SERVER_PORT>, где localhost - это адрес helios 
для него же, а SERVER_PORT - это порт вашего сайта
- `-N` - отключает запуск командной строки, эту опцию можно и 
не писать

Пока SSH работает можно подключиться из браузера к
```
http://localhost:8080
```
И надеюсь, что увидеть приветствие

## Дальнейшие действия

Дальше нужно переписать `www/index.html` с приветствием по заданию
лабораторной работы. В зависимости от варианта нужно либо создать файлы `www/script.js`
и `www/styles.css`, либо писать их внутри html.

### Запуск java приложения
Допустим, вы уже написали и собрали jarник используя данную
нам fastcgi библиотеку. 

Он запускается через
```bash
java -DFCGI_PORT=<ваш FCGI_PORT> -jar web1.jar
```
- `-DFCGI_PORT=<ваш FCGI_PORT>` - передаёт выбранный ранее порт через
переменные среды выполнения java.
- `-jar web1.jar` - запукает ваш jar файл, можно назвать его и по другому

Если и Apache, и java запущены и порты не перепутаны, то всё должно работать.
Когда будут проблемы, их следует искать файлах сайта или в коде.